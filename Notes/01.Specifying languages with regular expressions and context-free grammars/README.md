# Note
#### DATE: May 19, 2022
-----

# Specifying Formal Languages
* Two Dual Notions
    * Generative approach: Grammar or regular expression
    * Recognition approach: automaton
* Lots of theorems about converting one approach automatically to another

# Specifying Lexical Structure Using Regular Expressions
* Have some alphabet ∑ = set of letters
* Regular expressions are built from:
    * ε - empty string  
    Any letter from alphabet ∑
    * r1r2 - regular expression r1 followed by r2(sequence)
    * r1|r2 - either regular expression r1 or r2 (choice)
    * r* - iterated sequence and choice ε | r | rr | …
    * Parentheses to indicate grouping/precedence

 
# Concept of Language Generated by Regular Expressions 

* Set of all strings generated by a regular expression is language of regular expression
* In general, Language may be (countably) infinite
* String in language is often called a token

## Examples of Languages and Regular Expressions
* ∑ = { 0, 1, . } 
    * (0|1)*.(0|1)* - Binary floating point numbers
    * (00)* - even-length all-zero strings
    * 1*(01*01*)* - strings with even number of zeros
* ∑ = {a,b ,c ,0 ,1 ,2} 
    * (a|b|c)(a|b|c|0|1|2)* - alphanumeric identifiers
    (0|1|2)* - trinary numbers

# Properties of Regular expressions
* e1|e2 = e2|e1
* e1|(e2|e3) = (e1|e2)|e3
* e1|(e2e3) = (e1e2)e3
* e1(e2|e3) = e1e2|e1e3
* (e2|e3)e1 = e2e1|e3e1
* eε = εe = e

# Alternate Abstraction Finite-State Automata
* Alphabet ∑
* Set of states with initial and accept states
* Transitions between states, labeled with letters
* Automaton Accepting String
    * Have current state and current letter in string
    * Start with start state and first letter in string
    * At each step, match current letter against a transition whose label is same as letter
    * Continue until reach end of string or match fails
    * If end in accept state, automaton accepts string
    * Language of automaton is set of strings it accepts

# Generative Versus Recognition
* Regular expression give you a way to generate all strings in language
* Automata give you a way to recognize if a specific string is in language
    * Philosophically very different
    * Theoretically equivalent
* Standard approach 
    * Use regular expressions when define language
    * Translated automatically into automata for implementation
# From Regular Expressions to Automata
* Construction by structural induction
* Given an arbitrary regular expression r
* Assume we can convert r to an automaton with 
    * One start sate
    * One accept state

# NFA vs DFA
* DFA 
    * No ε transitions
    * At most one transition from each state for each letter
* NFA - neither restriction

# Conversions
* Regular expression to automata conversion produces an NFA
* Would like to have a DFA to make recognition algorithm simpler
* Can convert from NFA to DFA(but DFA may be exponentially larger than NFA)
# Parse Tess
* Internal Nodes: Nonterminals 
* Leaves: Terminals
* Edges:
    * from Nonterminal of LHS of production
    * To Nodes from RHS of production Captures derivation of string

# Ambiguity in Grammar
* Grammar is ambiguous if there are multiple derivations(multiple parse trees) for a single string
* Derivation and parse tree usually reflect semantics of the program
* Ambiguity in grammar often reflects ambiguity in semantics of language

# Eliminating Ambiguity
* hack the grammar: Conceptually,makes all operators associated to left

# Precedence Violations
* All operators associate to left
* Violates precedence of * over + 
    * 2-3*4 associates like <2-3>*4
    